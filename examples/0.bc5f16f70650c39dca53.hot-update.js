webpackHotUpdate(0,{

/***/ "../src/format-utils/format-utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _moment = __webpack_require__(\"../node_modules/moment/moment.js\");\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _formatUtils = __webpack_require__(\"../src/format-utils/format-utils.constants.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FormatUtils = function FormatUtils() {\n  var _this = this;\n\n  _classCallCheck(this, FormatUtils);\n\n  this.getCurrencyDecimals = function (currency) {\n    var numberOptions = {\n      currency: currency,\n      style: 'currency',\n      currencyDisplay: 'code',\n      useGrouping: false\n    };\n    var test = new Intl.NumberFormat('en-GB', numberOptions).format(1.111111).replace(/[^\\d.,]/g, '');\n    var foundSeparator = test.search(/[.,]/g);\n    if (foundSeparator === -1) {\n      return 0;\n    }\n    return test.length - foundSeparator - 1;\n  };\n\n  this.getFXRateDecimals = function (value) {\n    var valueString = String(parseFloat(String(value)));\n    var decimalSeparator = valueString.indexOf('.');\n    var decimalNumber = valueString.length - decimalSeparator - 1;\n    return decimalSeparator === -1 || decimalNumber <= _formatUtils.FXRATE_DECIMALS ? _formatUtils.FXRATE_DECIMALS : decimalNumber;\n  };\n\n  this.getLocalDateTime = function (timestamp) {\n    var isoTimestamp = timestamp !== null && timestamp.slice(-1) !== 'Z' ? timestamp + 'Z' : timestamp;\n    var localTime = new Date(isoTimestamp) - new Date(timestamp).getTimezoneOffset();\n    var timeToConvert = localTime >= 0 ? localTime : 0;\n    return new Date(timeToConvert);\n  };\n\n  this.formatCurrencyAmount = function (value, currency) {\n    return Number(value).toFixed(_this.getCurrencyDecimals(currency));\n  };\n\n  this.formatFXRate = function (value) {\n    return Number(value).toFixed(_this.getFXRateDecimals(value));\n  };\n\n  this.formatFloatToFixedDecimals = function (value, decimals) {\n    /* eslint-disable no-restricted-globals */\n    var floatValue = String(value).replace(/[^\\d.,-]/g, '').replace(',', '.');\n    floatValue = isNaN(Number(floatValue)) ? 0 : Number(floatValue);\n    return floatValue.toFixed(decimals);\n  };\n\n  this.formatDate = function (value, dateFormat) {\n    if (value === null) {\n      return '';\n    }\n    if (_moment2.default.utc(value, _formatUtils.SKIPPED_DATE_FORMAT, true).isValid()) {\n      return value;\n    }\n    if (_moment2.default.utc(value, _moment2.default.ISO_8601, true).isValid()) {\n      return _moment2.default.utc(value, _moment2.default.ISO_8601, true).format(dateFormat);\n    }\n    return value;\n  };\n\n  this.formatDateToISO = function (value) {\n    var dateFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var isStrict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    var defaultDateFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n    if (isStrict && _moment2.default.utc(value, _formatUtils.SKIPPED_DATE_FORMAT, isStrict).isValid()) {\n      return value;\n    }\n    if (_moment2.default.utc(value, _moment2.default.ISO_8601, isStrict).isValid()) {\n      return _moment2.default.utc(value, _moment2.default.ISO_8601, isStrict).toISOString();\n    }\n    if (dateFormat !== null && _moment2.default.utc(value, dateFormat, isStrict).isValid()) {\n      return _moment2.default.utc(value, dateFormat, isStrict).toISOString();\n    }\n    if (defaultDateFormat !== null && _moment2.default.utc(value, defaultDateFormat, isStrict).isValid()) {\n      return _moment2.default.utc(value, defaultDateFormat, isStrict).toISOString();\n    }\n    return defaultValue;\n  };\n\n  this.parseDate = function (value, dateFormat) {\n    var newFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (_moment2.default.utc(value, dateFormat).isValid()) {\n      return newFormat === null ? _moment2.default.utc(value, dateFormat).toISOString() : _moment2.default.utc(value, dateFormat).format(newFormat);\n    } else if (_moment2.default.utc(value, _moment2.default.ISO_8601).isValid()) {\n      return newFormat === null ? _moment2.default.utc(value, _moment2.default.ISO_8601).toISOString() : _moment2.default.utc(value, _moment2.default.ISO_8601).format(newFormat);\n    }\n    return null;\n  };\n\n  this.parseFloat = function (value, decimalSeparator) {\n    if (!value || String(value).length === 0) {\n      return value;\n    }\n    return String(value).replace(decimalSeparator, '.');\n  };\n\n  this.parseNumber = function (value) {\n    return String(value).replace(/[^\\d-]/g, '') || '';\n  };\n}\n/**\n * Get a number of decimal digits for a currency.\n * Input: currency code :: string.\n * Output: decimals :: number.\n * Example of input: 'EUR'. Example of output: 2.\n * Example of input: 'JPY'. Example of output: 0.\n */\n\n\n/**\n * Get a number of decimal digits for a FX rate.\n * Input: rate :: [number, string].\n * Output: decimals :: number.\n * Example of input: 1.11. Example of output: 6.\n * Example of input: 1.12345678. Example of output: 8.\n */\n\n\n/**\n * Get local date and time from ISO 8601 timestamp. It's cross-browser (IE especially!).\n  * Input: UTC timestamp :: string.\n  * Output: timestamp :: date.\n  */\n\n\n/**\n * Format amount according to its currency.\n * Input: amount :: [number, string], currency code :: string.\n * Output: amount :: string.\n * Example of input: 1, 'EUR'. Example of output: '1.00'.\n * Example of input: 1.123, 'JPY'. Example of output: '1'.\n */\n\n\n/**\n * Format FX rate.\n * Input: rate.\n * Output: rate :: string.\n * Example of input: 1.11. Example of output: '1.110000'.\n * Example of input: 1.12345678. Example of output: '1.12345678'.\n */\n\n\n/**\n * Format an input to a float with fixed number of decimals.\n * Input: value to format :: [number, string], decimals :: number.\n * Output: formatted value :: string.\n * Example of input: '23 000.1abc', '2'. Example of output: '23000.10'.\n */\n\n\n/**\n * Format date to a chosen format.\n * Input: date :: string, date format :: string.\n * Output: date :: string.\n * Example of input: '2017-01-01T00:00:00.000Z', 'DD.MM.YYYY'. Example of output: '01.01.2017'.\n */\n\n\n/**\n * Format localized date string to ISO timestamp.\n * Input: date :: string, date format :: string (optional), sign of strict date format ::\n * boolean (optional), default value :: string (optional), default date format ::\n * string (optional).\n * Output: ISO timestamp :: string.\n * Example of input: '01.01', 'DD.MM.YYYY'. Example of output: '2017-01-01T00:00:00.000Z'.\n */\n\n\n/**\n * Parse date string to ISO string or a new format.\n * Input: date :: string, date format :: string, new date format :: string (optional).\n * Output: date :: string.\n * Example of input: '01.01.2017', 'DD.MM.YYYY'. Example of output: '2017-01-01T00:00:00.000Z'.\n * Example of input: '01.01.2017', 'DD.MM.YYYY', 'YYYY-MM-DD'. Example of output: '2017-01-01'.\n */\n\n\n/**\n * Parse float.\n * Input: value :: [number, string], decimal separator :: string.\n * Output: value :: string.\n * Example of input: '1,1', ','. Example of output: '1.1'.\n */\n\n\n/**\n * Parse number.\n * Input: value :: [number, string].\n * Output: value :: string.\n * Example of input: '1ab'. Example of output: '1'.\n */\n;\n\nexports.default = new FormatUtils();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2Zvcm1hdC11dGlscy9mb3JtYXQtdXRpbHMuanM/Y2MwMiJdLCJuYW1lcyI6WyJGb3JtYXRVdGlscyIsImdldEN1cnJlbmN5RGVjaW1hbHMiLCJjdXJyZW5jeSIsIm51bWJlck9wdGlvbnMiLCJzdHlsZSIsImN1cnJlbmN5RGlzcGxheSIsInVzZUdyb3VwaW5nIiwidGVzdCIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJmb3JtYXQiLCJyZXBsYWNlIiwiZm91bmRTZXBhcmF0b3IiLCJzZWFyY2giLCJsZW5ndGgiLCJnZXRGWFJhdGVEZWNpbWFscyIsInZhbHVlIiwidmFsdWVTdHJpbmciLCJTdHJpbmciLCJwYXJzZUZsb2F0IiwiZGVjaW1hbFNlcGFyYXRvciIsImluZGV4T2YiLCJkZWNpbWFsTnVtYmVyIiwiZ2V0TG9jYWxEYXRlVGltZSIsInRpbWVzdGFtcCIsImlzb1RpbWVzdGFtcCIsInNsaWNlIiwibG9jYWxUaW1lIiwiRGF0ZSIsImdldFRpbWV6b25lT2Zmc2V0IiwidGltZVRvQ29udmVydCIsImZvcm1hdEN1cnJlbmN5QW1vdW50IiwiTnVtYmVyIiwidG9GaXhlZCIsImZvcm1hdEZYUmF0ZSIsImZvcm1hdEZsb2F0VG9GaXhlZERlY2ltYWxzIiwiZGVjaW1hbHMiLCJmbG9hdFZhbHVlIiwiaXNOYU4iLCJmb3JtYXREYXRlIiwiZGF0ZUZvcm1hdCIsInV0YyIsImlzVmFsaWQiLCJJU09fODYwMSIsImZvcm1hdERhdGVUb0lTTyIsImlzU3RyaWN0IiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdERhdGVGb3JtYXQiLCJ0b0lTT1N0cmluZyIsInBhcnNlRGF0ZSIsIm5ld0Zvcm1hdCIsInBhcnNlTnVtYmVyIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7QUFFQTs7Ozs7O0lBS01BLFc7Ozs7O09BUUpDLG1CLEdBQXNCLFVBQUNDLFFBQUQsRUFBYztBQUNsQyxRQUFNQyxnQkFBZ0I7QUFDcEJELHdCQURvQjtBQUVwQkUsYUFB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O0FBYUE7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7a0JBU2EsSUFBSVgsV0FBSixFIiwiZmlsZSI6Ii4uL3NyYy9mb3JtYXQtdXRpbHMvZm9ybWF0LXV0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuXG5pbXBvcnQge1xuICBGWFJBVEVfREVDSU1BTFMsXG4gIFNLSVBQRURfREFURV9GT1JNQVQsXG59IGZyb20gJy4vZm9ybWF0LXV0aWxzLmNvbnN0YW50cyc7XG5cbmNsYXNzIEZvcm1hdFV0aWxzIHtcbiAgLyoqXG4gICAqIEdldCBhIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cyBmb3IgYSBjdXJyZW5jeS5cbiAgICogSW5wdXQ6IGN1cnJlbmN5IGNvZGUgOjogc3RyaW5nLlxuICAgKiBPdXRwdXQ6IGRlY2ltYWxzIDo6IG51bWJlci5cbiAgICogRXhhbXBsZSBvZiBpbnB1dDogJ0VVUicuIEV4YW1wbGUgb2Ygb3V0cHV0OiAyLlxuICAgKiBFeGFtcGxlIG9mIGlucHV0OiAnSlBZJy4gRXhhbXBsZSBvZiBvdXRwdXQ6IDAuXG4gICAqL1xuICBnZXRDdXJyZW5jeURlY2ltYWxzID0gKGN1cnJlbmN5KSA9PiB7XG4gICAgY29uc3QgbnVtYmVyT3B0aW9ucyA9IHtcbiAgICAgIGN1cnJlbmN5LFxuICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXG4gICAgICBjdXJyZW5jeURpc3BsYXk6ICdjb2RlJyxcbiAgICAgIHVzZUdyb3VwaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IHRlc3QgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLUdCJywgbnVtYmVyT3B0aW9ucykuZm9ybWF0KDEuMTExMTExKS5yZXBsYWNlKC9bXlxcZC4sXS9nLCAnJyk7XG4gICAgY29uc3QgZm91bmRTZXBhcmF0b3IgPSB0ZXN0LnNlYXJjaCgvWy4sXS9nKTtcbiAgICBpZiAoZm91bmRTZXBhcmF0b3IgPT09IC0xKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRlc3QubGVuZ3RoIC0gZm91bmRTZXBhcmF0b3IgLSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cyBmb3IgYSBGWCByYXRlLlxuICAgKiBJbnB1dDogcmF0ZSA6OiBbbnVtYmVyLCBzdHJpbmddLlxuICAgKiBPdXRwdXQ6IGRlY2ltYWxzIDo6IG51bWJlci5cbiAgICogRXhhbXBsZSBvZiBpbnB1dDogMS4xMS4gRXhhbXBsZSBvZiBvdXRwdXQ6IDYuXG4gICAqIEV4YW1wbGUgb2YgaW5wdXQ6IDEuMTIzNDU2NzguIEV4YW1wbGUgb2Ygb3V0cHV0OiA4LlxuICAgKi9cbiAgZ2V0RlhSYXRlRGVjaW1hbHMgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZVN0cmluZyA9IFN0cmluZyhwYXJzZUZsb2F0KFN0cmluZyh2YWx1ZSkpKTtcbiAgICBjb25zdCBkZWNpbWFsU2VwYXJhdG9yID0gdmFsdWVTdHJpbmcuaW5kZXhPZignLicpO1xuICAgIGNvbnN0IGRlY2ltYWxOdW1iZXIgPSB2YWx1ZVN0cmluZy5sZW5ndGggLSBkZWNpbWFsU2VwYXJhdG9yIC0gMTtcbiAgICByZXR1cm4gKGRlY2ltYWxTZXBhcmF0b3IgPT09IC0xIHx8IGRlY2ltYWxOdW1iZXIgPD0gRlhSQVRFX0RFQ0lNQUxTKSA/XG4gICAgICBGWFJBVEVfREVDSU1BTFMgOiBkZWNpbWFsTnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsb2NhbCBkYXRlIGFuZCB0aW1lIGZyb20gSVNPIDg2MDEgdGltZXN0YW1wLiBJdCdzIGNyb3NzLWJyb3dzZXIgKElFIGVzcGVjaWFsbHkhKS5cbiAgICAqIElucHV0OiBVVEMgdGltZXN0YW1wIDo6IHN0cmluZy5cbiAgICAqIE91dHB1dDogdGltZXN0YW1wIDo6IGRhdGUuXG4gICAgKi9cbiAgZ2V0TG9jYWxEYXRlVGltZSA9ICh0aW1lc3RhbXApID0+IHtcbiAgICBjb25zdCBpc29UaW1lc3RhbXAgPSAodGltZXN0YW1wICE9PSBudWxsICYmIHRpbWVzdGFtcC5zbGljZSgtMSkgIT09ICdaJykgP1xuICAgICAgYCR7dGltZXN0YW1wfVpgIDogdGltZXN0YW1wO1xuICAgIGNvbnN0IGxvY2FsVGltZSA9IG5ldyBEYXRlKGlzb1RpbWVzdGFtcCkgLSBuZXcgRGF0ZSh0aW1lc3RhbXApLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgY29uc3QgdGltZVRvQ29udmVydCA9IGxvY2FsVGltZSA+PSAwID8gbG9jYWxUaW1lIDogMDtcbiAgICByZXR1cm4gbmV3IERhdGUodGltZVRvQ29udmVydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhbW91bnQgYWNjb3JkaW5nIHRvIGl0cyBjdXJyZW5jeS5cbiAgICogSW5wdXQ6IGFtb3VudCA6OiBbbnVtYmVyLCBzdHJpbmddLCBjdXJyZW5jeSBjb2RlIDo6IHN0cmluZy5cbiAgICogT3V0cHV0OiBhbW91bnQgOjogc3RyaW5nLlxuICAgKiBFeGFtcGxlIG9mIGlucHV0OiAxLCAnRVVSJy4gRXhhbXBsZSBvZiBvdXRwdXQ6ICcxLjAwJy5cbiAgICogRXhhbXBsZSBvZiBpbnB1dDogMS4xMjMsICdKUFknLiBFeGFtcGxlIG9mIG91dHB1dDogJzEnLlxuICAgKi9cbiAgZm9ybWF0Q3VycmVuY3lBbW91bnQgPSAodmFsdWUsIGN1cnJlbmN5KSA9PlxuICAgIE51bWJlcih2YWx1ZSkudG9GaXhlZCh0aGlzLmdldEN1cnJlbmN5RGVjaW1hbHMoY3VycmVuY3kpKTtcblxuICAvKipcbiAgICogRm9ybWF0IEZYIHJhdGUuXG4gICAqIElucHV0OiByYXRlLlxuICAgKiBPdXRwdXQ6IHJhdGUgOjogc3RyaW5nLlxuICAgKiBFeGFtcGxlIG9mIGlucHV0OiAxLjExLiBFeGFtcGxlIG9mIG91dHB1dDogJzEuMTEwMDAwJy5cbiAgICogRXhhbXBsZSBvZiBpbnB1dDogMS4xMjM0NTY3OC4gRXhhbXBsZSBvZiBvdXRwdXQ6ICcxLjEyMzQ1Njc4Jy5cbiAgICovXG4gIGZvcm1hdEZYUmF0ZSA9IHZhbHVlID0+IE51bWJlcih2YWx1ZSkudG9GaXhlZCh0aGlzLmdldEZYUmF0ZURlY2ltYWxzKHZhbHVlKSk7XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhbiBpbnB1dCB0byBhIGZsb2F0IHdpdGggZml4ZWQgbnVtYmVyIG9mIGRlY2ltYWxzLlxuICAgKiBJbnB1dDogdmFsdWUgdG8gZm9ybWF0IDo6IFtudW1iZXIsIHN0cmluZ10sIGRlY2ltYWxzIDo6IG51bWJlci5cbiAgICogT3V0cHV0OiBmb3JtYXR0ZWQgdmFsdWUgOjogc3RyaW5nLlxuICAgKiBFeGFtcGxlIG9mIGlucHV0OiAnMjMgMDAwLjFhYmMnLCAnMicuIEV4YW1wbGUgb2Ygb3V0cHV0OiAnMjMwMDAuMTAnLlxuICAgKi9cbiAgZm9ybWF0RmxvYXRUb0ZpeGVkRGVjaW1hbHMgPSAodmFsdWUsIGRlY2ltYWxzKSA9PiB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG4gICAgbGV0IGZsb2F0VmFsdWUgPSBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1teXFxkLiwtXS9nLCAnJykucmVwbGFjZSgnLCcsICcuJyk7XG4gICAgZmxvYXRWYWx1ZSA9IGlzTmFOKE51bWJlcihmbG9hdFZhbHVlKSkgPyAwIDogTnVtYmVyKGZsb2F0VmFsdWUpO1xuICAgIHJldHVybiBmbG9hdFZhbHVlLnRvRml4ZWQoZGVjaW1hbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBkYXRlIHRvIGEgY2hvc2VuIGZvcm1hdC5cbiAgICogSW5wdXQ6IGRhdGUgOjogc3RyaW5nLCBkYXRlIGZvcm1hdCA6OiBzdHJpbmcuXG4gICAqIE91dHB1dDogZGF0ZSA6OiBzdHJpbmcuXG4gICAqIEV4YW1wbGUgb2YgaW5wdXQ6ICcyMDE3LTAxLTAxVDAwOjAwOjAwLjAwMFonLCAnREQuTU0uWVlZWScuIEV4YW1wbGUgb2Ygb3V0cHV0OiAnMDEuMDEuMjAxNycuXG4gICAqL1xuICBmb3JtYXREYXRlID0gKHZhbHVlLCBkYXRlRm9ybWF0KSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChtb21lbnQudXRjKHZhbHVlLCBTS0lQUEVEX0RBVEVfRk9STUFULCB0cnVlKS5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKG1vbWVudC51dGModmFsdWUsIG1vbWVudC5JU09fODYwMSwgdHJ1ZSkuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gbW9tZW50LnV0Yyh2YWx1ZSwgbW9tZW50LklTT184NjAxLCB0cnVlKS5mb3JtYXQoZGF0ZUZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IGxvY2FsaXplZCBkYXRlIHN0cmluZyB0byBJU08gdGltZXN0YW1wLlxuICAgKiBJbnB1dDogZGF0ZSA6OiBzdHJpbmcsIGRhdGUgZm9ybWF0IDo6IHN0cmluZyAob3B0aW9uYWwpLCBzaWduIG9mIHN0cmljdCBkYXRlIGZvcm1hdCA6OlxuICAgKiBib29sZWFuIChvcHRpb25hbCksIGRlZmF1bHQgdmFsdWUgOjogc3RyaW5nIChvcHRpb25hbCksIGRlZmF1bHQgZGF0ZSBmb3JtYXQgOjpcbiAgICogc3RyaW5nIChvcHRpb25hbCkuXG4gICAqIE91dHB1dDogSVNPIHRpbWVzdGFtcCA6OiBzdHJpbmcuXG4gICAqIEV4YW1wbGUgb2YgaW5wdXQ6ICcwMS4wMScsICdERC5NTS5ZWVlZJy4gRXhhbXBsZSBvZiBvdXRwdXQ6ICcyMDE3LTAxLTAxVDAwOjAwOjAwLjAwMFonLlxuICAgKi9cbiAgZm9ybWF0RGF0ZVRvSVNPID0gKHZhbHVlLCBkYXRlRm9ybWF0ID0gbnVsbCwgaXNTdHJpY3QgPSBmYWxzZSwgZGVmYXVsdFZhbHVlID0gJycsIGRlZmF1bHREYXRlRm9ybWF0ID0gbnVsbCkgPT4ge1xuICAgIGlmIChpc1N0cmljdCAmJiBtb21lbnQudXRjKHZhbHVlLCBTS0lQUEVEX0RBVEVfRk9STUFULCBpc1N0cmljdCkuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChtb21lbnQudXRjKHZhbHVlLCBtb21lbnQuSVNPXzg2MDEsIGlzU3RyaWN0KS5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBtb21lbnQudXRjKHZhbHVlLCBtb21lbnQuSVNPXzg2MDEsIGlzU3RyaWN0KS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZGF0ZUZvcm1hdCAhPT0gbnVsbCAmJiBtb21lbnQudXRjKHZhbHVlLCBkYXRlRm9ybWF0LCBpc1N0cmljdCkuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gbW9tZW50LnV0Yyh2YWx1ZSwgZGF0ZUZvcm1hdCwgaXNTdHJpY3QpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0RGF0ZUZvcm1hdCAhPT0gbnVsbCAmJiBtb21lbnQudXRjKHZhbHVlLCBkZWZhdWx0RGF0ZUZvcm1hdCwgaXNTdHJpY3QpLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIG1vbWVudC51dGModmFsdWUsIGRlZmF1bHREYXRlRm9ybWF0LCBpc1N0cmljdCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgZGF0ZSBzdHJpbmcgdG8gSVNPIHN0cmluZyBvciBhIG5ldyBmb3JtYXQuXG4gICAqIElucHV0OiBkYXRlIDo6IHN0cmluZywgZGF0ZSBmb3JtYXQgOjogc3RyaW5nLCBuZXcgZGF0ZSBmb3JtYXQgOjogc3RyaW5nIChvcHRpb25hbCkuXG4gICAqIE91dHB1dDogZGF0ZSA6OiBzdHJpbmcuXG4gICAqIEV4YW1wbGUgb2YgaW5wdXQ6ICcwMS4wMS4yMDE3JywgJ0RELk1NLllZWVknLiBFeGFtcGxlIG9mIG91dHB1dDogJzIwMTctMDEtMDFUMDA6MDA6MDAuMDAwWicuXG4gICAqIEV4YW1wbGUgb2YgaW5wdXQ6ICcwMS4wMS4yMDE3JywgJ0RELk1NLllZWVknLCAnWVlZWS1NTS1ERCcuIEV4YW1wbGUgb2Ygb3V0cHV0OiAnMjAxNy0wMS0wMScuXG4gICAqL1xuICBwYXJzZURhdGUgPSAodmFsdWUsIGRhdGVGb3JtYXQsIG5ld0Zvcm1hdCA9IG51bGwpID0+IHtcbiAgICBpZiAobW9tZW50LnV0Yyh2YWx1ZSwgZGF0ZUZvcm1hdCkuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gbmV3Rm9ybWF0ID09PSBudWxsID8gbW9tZW50LnV0Yyh2YWx1ZSwgZGF0ZUZvcm1hdCkudG9JU09TdHJpbmcoKSA6XG4gICAgICAgIG1vbWVudC51dGModmFsdWUsIGRhdGVGb3JtYXQpLmZvcm1hdChuZXdGb3JtYXQpO1xuICAgIH0gZWxzZSBpZiAobW9tZW50LnV0Yyh2YWx1ZSwgbW9tZW50LklTT184NjAxKS5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBuZXdGb3JtYXQgPT09IG51bGwgPyBtb21lbnQudXRjKHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpLnRvSVNPU3RyaW5nKCkgOlxuICAgICAgICBtb21lbnQudXRjKHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpLmZvcm1hdChuZXdGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBmbG9hdC5cbiAgICogSW5wdXQ6IHZhbHVlIDo6IFtudW1iZXIsIHN0cmluZ10sIGRlY2ltYWwgc2VwYXJhdG9yIDo6IHN0cmluZy5cbiAgICogT3V0cHV0OiB2YWx1ZSA6OiBzdHJpbmcuXG4gICAqIEV4YW1wbGUgb2YgaW5wdXQ6ICcxLDEnLCAnLCcuIEV4YW1wbGUgb2Ygb3V0cHV0OiAnMS4xJy5cbiAgICovXG4gIHBhcnNlRmxvYXQgPSAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IpID0+IHtcbiAgICBpZiAoIXZhbHVlIHx8IFN0cmluZyh2YWx1ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJy4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBudW1iZXIuXG4gICAqIElucHV0OiB2YWx1ZSA6OiBbbnVtYmVyLCBzdHJpbmddLlxuICAgKiBPdXRwdXQ6IHZhbHVlIDo6IHN0cmluZy5cbiAgICogRXhhbXBsZSBvZiBpbnB1dDogJzFhYicuIEV4YW1wbGUgb2Ygb3V0cHV0OiAnMScuXG4gICAqL1xuICBwYXJzZU51bWJlciA9IHZhbHVlID0+IChTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1teXFxkLV0vZywgJycpIHx8ICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IEZvcm1hdFV0aWxzKCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vc3JjL2Zvcm1hdC11dGlscy9mb3JtYXQtdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/format-utils/format-utils.js\n");

/***/ })

})